# 垃圾回收器（垃圾回收算法是方法论，垃圾回收器是具体实现）

```mermaid
graph LR
A("垃圾回收器")-->B("Serial收集器")
A -->C("ParNew收集器")
#A -->D("ParNew收集器")
A -->E("Parallel收集器")
A -->F("CMS收集器")
A -->G("G1收集器")
```

![jvm_gc](D:\project\huan415\ssh\JavaYang\jvm\assets\jvm_gc.jpg)

## Serial收集器(串行  -XX:+UseSerialGC -XX:+UseSerialOldGC)

Serial Old收集器是Serial收集器的老年代版本

新生代：复制算法
老年代：标记-整理算法



## ParNew收集器(-XX:+UseParNewGC)

Serial收集器的多线程版本，线程数==cpu核数

新生代：复制算法
老年代：标记整理算法



## Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),- XX:+UseParallelOldGC(老年代))

Parallel Old收集器是Parallel Scavenge收集器的老年代版本

新生代：复制算法
老年代：标记整理算法

目标：高吞吐量（CPU利用率高）



## CMS收集器（Concurrent Mark Sweep）(-XX:+UseConcMarkSweepGC(old))

标记-清除算法

目标：最短停顿时间

只能用在老年代、不能用在年轻代

优点：并发收集、低延迟
缺点：

* 标记清除产生空间碎片, 需要重新整理空间-XX:+UseCMSCompactAtFullCollection
* 跟CPU抢资源
* 浮动垃圾（并发清理阶段产生的垃圾）要等到下一次gc才能回收 
* 第一次垃圾还未结束，又触发了垃圾回收--是"concurrent mode failure"，此时不再用CMS，改为serial old



## G1收集器(-XX:+UseG1GC)

Garbage-First：在指定的时间里，回收价值最大的Region(筛选回收阶段做计算)

复制算法：一个Region里存活的对象复制到另一个Region.(不会有空间碎片)

Region区：2048个，-XX:G1HeapRegionSize指定大小。Redion被回收之后重新开始，可能是老年代、也可能是年轻代
Humongous区：放大对象(大小超过Region 50%)，目的：节约老年代空间（老年代不足导致的gc）

-XX:MaxGCPauseMillis指定回收停顿时间，这个参数可能导致回收部分Region。所以“筛选回收阶段”会对每个Region的回收价值和成本进行排（回收价值最大）。

### G1垃圾回收器分类

1. YoungGC

   新生代空间默认堆的5%；指定大小：-XX:G1NewSizePercent
   如果时间远远小于 -XX:MaxGCPauseMills，没有必要直接YoungGC

   ![G1_YoungGC](https://raw.githubusercontent.com/huan415/JavaYang/master/assets/G1_YoungGC.jpg)

2. MixedGC
   老年代空间达到阈值（-XX:InitiatingHeapOccupancyPercen），回收Young区、old区、Humongous区。
   复制算法：各个Region存活的对象拷贝到新的Region。弱Region不够，触发Full GC.

3. Full GC
   stop the world. 整理出新的Region给下一次mixedGC

### Remenber Set（RS）和Card Table

1. Remenber Set 引言
   **跨代引用：**一个Region里面的对象可能被其他Region引用，那么如果只回收这个Region，有必要所有Region都扫描吗？
   *解决思路：每个Region都维护一个集合，记录当前Region被哪些Region引用，这样就不用全部Region都扫描*
2. RS(Remember Set)
   一个Region指向其他Region的指针集合。
3. Card Table 引言
   如果每次一个线程修改了Region里的对象引用，都去通知另外一个线程修改RS，这涉及到上下文切换，浪费性能。
   *解决思路：一种新的接口，每次修改Region里对象的数据，将其修改为脏数据，然后在慢慢地记录到RS，如果脏数据生成过快，会阻塞业务线程*
4. Card Table------卡表
   将Region分成若张卡，每一张卡一个byte，记录是否被修改过
5. 写栅栏------RSet也不会立即更新
   * 写前栅栏
   * 写后栅栏
6. STAB
   

### 三色标记算法

1. 黑色：跟对象
2. 灰色：被跟对象直接引用
3. 白色：未被扫描的对象-------**垃圾对象**

### 写屏障与STAB

1. 引言
   白色对象，并发标记时，被修改了怎么办？
   * 在插入的时候
   * 在删除的时候
2. 写屏障
   白色对象引用被赋值到黑色对象里，将白色变为灰色
3. STAB（snapshot-at-the-beginning）
   * 开始标记的时候生成快照，标记存活对象
   * 并发标记期间，被改变的对象入队
   * 可能存在浮动对象，等下次回收

参考：

[<<G1垃圾收集器详解>>]: https://blog.csdn.net/qq_38294614/article/details/107746331



## GC组合

![jvm_gc_combination](https://raw.githubusercontent.com/huan415/JavaYang/master/assets/jvm_gc_combination.jpg)
