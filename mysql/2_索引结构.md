# 索引结构

## mysql为什么选择B+树

1. 二叉树： 树的结构太高（IO次数）

2. 红黑树： 树的结构太高（IO次数）、而且红黑树自旋时也会影响性能

3. Hash表：hash碰撞问题，范围查询不行、模糊查询不行

4. B树：比红黑树好--一个节点16kb, 可以放更多的节点，相同节点可以放更多的数据

5. B+树：节点不放数据，只放索引，16kb可以存储更多的数据，

   ​             B+树叶子节点有双向指针连接，可以范围查询



### MYISAM存储引擎、InnoDB存储引擎

### 区别：

1. InnoDB支持事务
   MYISAM 不支持事务
2. MYISAM 速度比 InnoDB快
3. InnoDB 聚簇索引 + 非聚簇索引，**所以必须有主键**
   MYISAM 非聚簇索引
4. InnoDB 不存储行数，select count(\*) 会全部扫描
   MYISAM 有一个变量存储了行数，select count(\*)  时性能高
5. InnoDB 是行锁
   MYISAM 是表锁

### MYISAM存储引擎

非聚集索引：索引文件和数据文件是分离的

#### 文件结构：

1. huan415_myisam.frm        表结构
2. huan415_myisam.MYD      表数据 （my + data）
3. huan415_myisam.MYI        表索引（my + index）

### InnoDB存储引擎

聚集索引：索引文件和数据文件在一起

#### 文件结构：

1. huan415_innodb.frm         表结构
2. huan415_innodb.ibd          表数据+表索引

+ innodb必须有主键----表数据放在主键索引的叶子节点

​       如果没有设置主键，这默认生成一个主键

+ 建议主键: 整型+自增

  因为自增索引是一直往后加，
  为什么不用uuid：
  
  1. uuid等可能触发重排序
  2. B+ 树的叶子节点16KB，存储的空间有限，一个叶子节点的如果存储uuid，索引的个数会减少很多
  3. 且长度长，查询时对比也有损耗



## 索引

1. 聚簇索引与非聚簇索引
   聚簇索引：数据跟索引存储在一起

   非聚簇索引：数据跟索引不在一起

   二级索引：叶子节点不是具体数据，而是主键值

   innodb: 既有聚簇索引，又有非聚簇索引

   myisam: 只有非聚簇索引
   
2. 联合索引、组合索引、复合索引
   多个字段组合成的索引，要符合最左前缀原则

3.  唯一索引
   字段必须唯一，允许为空值

4. 主键索引
   主键做的索引，叶子节点是具体数据

5. 



## 常见概念

1. 回表
   通过普通索引查到主键id(叶子节点)，再通过id回表查到完整数据
2. 覆盖索引
   普通索引的叶子节点包含了要查询的所有字段，不需要回表查
3. 最左匹配
   组合索引或者联合索引，要遵循最左匹配原则
4. 索引下推
   SELECT * FROM `yangyc`.`huan415_explain` WHERE f1='a' AND f2='a';
   没有索引下推：先根据f1从存储引擎中拉取数据到server层，然后在server层根据f2进行数据过滤
   有索引下推：根据f1和f2两个条件在存储引擎中进行过滤，之后将结果返回到server层
   索引下推：（前提：联合索引）
              根据联合索引本身就有的数据直接做一次过滤，而不用回表再到Server层进行过滤
   （`Using index condition`并不代表一定是使用了索引下推，只是代表可以使用，但是不一定用了）比较详细的url: https://mp.weixin.qq.com/s/czmUEm-FnU8hivHBlG-uTw
5. 

