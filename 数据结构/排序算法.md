# 排序算法

## 选择排序

基本不用

一遍一遍遍历，**每次遍历取出最小数**

时间复杂度O(n2)，空间辅助度O(1),  不稳定

```
/**
 * 选择排序： 两个for循环互相交换
 * 两层遍历：
 *  1. 第一层遍历：每个位置依次和最小值对调
 *  2. 第二层遍历：找出剩余元素的最小值
 *  3. i位置交换成最小值
 */
```

```java
public void sort(int[] arr){
        for (int i = 0; i < arr.length-1; i++) {
            int minPosition = i;
            //多次循环，每次循环找出最小位置
            //i已经确认比后面的小，从i+1开始遍历
            for (int j = i+1; j < arr.length; j++) {
                minPosition = arr[j] < arr[minPosition]?j:minPosition;
            }
            //每次循环，i位置和最小位置对调
            swap(arr,i,minPosition);
        }
    }
```





## 冒泡排序

基本不用

像冒泡一样，把最大的一个个晚上冒泡（通俗的理解：两次循环，第二轮把最大值一直交换，移到最后面）

时间复杂度O(n2)，空间辅助度O(1),  稳定

```java
// 与选择排序相反：
// 1. 选择排序是每次把最小值拉到最前面 
// 1. 冒泡排序是每次把最大值拉到最前面 

public void sort(int[] arr){
        for (int i = arr.length-1; i >0 ; i--) {
            // 第二轮循环，每次循环把最大值移到最后面
            for (int j = 0; j < i; j++) {
                if(arr[j] > arr[j+1]){
                    // 前面的数字 > 后面的数字，即交换 == 把最大值移到最后面
                    swap(arr,j,j+1);
                }
            }
        }
    }
```





## 插入排序（让前面某几个数有序，下一个数插入有序数组中插入）

遍历元素，每个元素与前面的元素对比，比前面小就往前挪（类似冒泡，不一样的是挪动小元素）

时间复杂度O(n2)，空间辅助度O(1),  稳定

```java
// 类似冒泡，不一样的是挪动小元素

public void sort(int[] arr){
        //遍历每个元素,下面有j=i,j--,所以这里从1开始
        for (int i = 1; i < arr.length; i++) {
            //j=i; 第i个元素与前面每个元素对比，如果比较小就往前插
            for (int j = i; j >0 && arr[j] < arr[j-1] ; j--) {
                swap(arr,j,j-1);
            }
        }
    }
```





## 希尔排序----改进的插入排序

给定一定间隔，按间隔进行插入排序，排完之后缩小间隔再排，最后一定要经过间隔=1最终排序

跳着排，缩小对比次数（比如小元素再最后，对比很多遍）

时间复杂度O(n1.3)，空间辅助度O(1),  稳定



## 归并排序

递归切半，然后分别合并（两个数组合并时排序）

时间复杂度O(log2n)，空间辅助度O(n),  稳定

java 对象排序采用的是归并排序

对象排序一般要求稳定



## 快速排序----双轴快排

例子：Array.sort

时间复杂度O(nlogn)，空间辅助度O(1),  稳定

单轴排序只有一根轴：左、右

双轴排序有两根轴：左、中、有



## 计数排序

非比较排序    桶思想的一种

试用范围： 量大、范围小

旧数组的值做下标，循环累计出现次数，所以使用范围：值范围小



## 基数排序

非比较排序    桶思想的一种

多关键字排序

分为地位优先和高位优先两种（例如：从个位数开始到最高位）